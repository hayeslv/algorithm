给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交：

![相交链表1](..\assets\相交链表1.png)

**注意**

- 如果两个链表没有交点，返回 null.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。



## 解法一：标记法

简单但空间复杂度为O(n)，不符合，仅做参考

解题思路：两次遍历，先遍历一个链表，给链表中的每个节点都增加一个标志位，然后遍历另外一个链表，遍历到第一个已被标志过的节点为两链表相交的起始节点。

若遍历完都没有发现已被标志过的节点，则两链表不相交，返回 null

```js
var getIntersectionNode = function(headA, headB) {
  while(headA) {
    headA.flag = true
    headA = headA.next
  }
  while(headB) {
    if(headB.flag) return headB
    headB = headB.next
  }
  return null
}
```



## 解法二：双指针法

解题思路：如果A、B两链表相交，则A、B自相交点往后的链表是一致的。

![相交链表2](F:\study\http-git\algorithm\leetcode\assets\相交链表2.png)

我们可以尝试消除A、B链表的长度差，同步遍历图中方框里的节点，判断是否有相同节点，若有相同则是两链表相交，返回第一个相同节点即可。否则返回 null。

**解题步骤：**

- 同步遍历A、B链表 **pA**、**pB**，直到遍历完其中一个链表（短链表），如上图，设A为长链表
- 那么此时A、B两链表的长度差就为 **pA** 到链表尾部的长度，此时可以把 **pB** 指向长链表的表头 **headA**，继续同步遍历，直到遍历完长链表
- 此时，**headA** 到 **pB**的长度就为两链表的长度差，pB到链尾的长度与headB到链表尾部的长度一致
- 此时，可将**pA**指向**headB**，然后同步遍历 **pB** 及 **pA**，直到有相交节点，返回相交节点，否则返回 null

图示如下：

<img src="..\assets\相交链表3.png" alt="相交链表3" style="zoom: 25%;" />























