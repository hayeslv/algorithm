### N数之和

请用算法实现，从给定的无序、不重复的数组A中，取出N个数，使其想加和为M。并给出算法的时间、空间复杂度，如：

```js
var arr = [1, 4, 7, 11, 9, 8, 10, 6];
var N = 3;
var M = 27;
Result:
[7, 11, 9], [11, 10, 6], [9, 8, 10]
```



### 解题思路：利用二进制

根据数组长度构建二进制数据，再选择其中满足条件的数据。

我们用 1 和 0 来表示数组中某位元素是否被选中。因此，可以用 0110 来表示数组中第 1 位和第 2 位被选中了。

所以，本题可以解读为：

- 数组中被选中的个数是 N
- 被选中的和是 M

最终题解为：遍历所有二进制，判断选中的个数是否为 N，然后再求对应的元素之和，看其是否为 M



#### 1、从数组中取出N个数

例如：

```js
var arr = [1, 2, 3, 4];
var N = 3;
var M = 6;
```

如何判断 N=3 时，对应的选取二进制中有几个 1 呢？

最简单的方式就是：

```js
const n = num => num.toString(2).replace(/0/g, '').length
```

这里我们尝试一下用位运算来解决本题，因为位运算是不需要编译的（位运算直接用二进制进行标识，省去了中间过程的各种复杂转换，提高了速度），肯定速度最快。

我们知道 1&0=0、1&1=1、1111&1110=1110，即 15&14=14；1110&1101=1100，即14&13=12；所以我们每次&比自身小 1 的数都会消除一个 1，这里建立一个迭代，通过统计消除的次数，就能确定最终有几个 1 了。

```js
const n = num => {
  let count = 0;
  while(num) {
    num &= (num - 1)
    count++
  }
  return count
}
```



#### 2、和为M

现在最后一层判断的就是选取的这些数字和必须等于M，即根据N生成的对应二进制所在元素上的和是否为M

比如 1110，我们应该判断 arr[0] + arr[1] + arr[2] 是否为 M

那么问题也就转化成了如何判断数组下标是否在 1110 中？

比如下标 1 在，而下标 3 不在。我们把 1 转换成 0100,  1110 & 0100 为 0100，大于0，因此下标 1 在，而 1110 & 0001 为 0，因此下标 3 不在

所以求和我们可以如下实现：

```js
let arr = [1,2,3,4]
// i为满足条件的二进制
let i = 0b1110
let s = 0, temp = []
let len = arr.length
for(let j=0; j<len; j++) {
  if(i & 1 << (len - 1 - j)) {
    s += arr[j]
    temp.push(arr[j])
  }
}
console.log(temp) // [1,2,3]
```

 

最终实现

```js
// 参数依次为目标数组、选取元素数目、目标和
const search = (arr, count, sum) => {
  // 计算某选择情况下有几个 1，也就是选择元素的个数
  const getCount = num => {
    let count = 0
    w
  }
}
```



















































