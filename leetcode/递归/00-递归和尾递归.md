# 递归和尾递归的区别和原理

## 1、递归

​		程序调用自身的编程技巧称为**递归**（ recursion）。它通常把一个**大型复杂的问题**层层转化为一个与原问题相似的**规模较小的问题**来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地**减少了程序的代码量**。

​		递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有**边界条件、递归前进段和递归返回段**。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。



定义如下：

递归，就是在运行的过程中调用自己。

构成递归需要具备的条件：

1. 子问题需同原始问题为同样的事，且更为简单；
2. 不能无限制地调用自身，需要有个出口，化简为非递归状态处理。



**以递归方式实现阶乘函数：**

```js
function face(n) {
  if(n < 0) return 0;
  if(n === 0 || n === 1) return 1;
  return n * fact(n - 1);
}
```



​		在程序中调用了一个函数时，栈中会分配一块空间来保存与这个调用相关的信息，**每一个调用都被当作是活跃的**。栈上的那块存储空间成为**活跃记录或者栈帧**。

​		栈帧由5个区域组成：**输入参数**、**返回值空间**、计算表达式时用到的**临时存储空间**、函数调用时保存的**状态信息**以及**输出参数**。

栈是用来存储函数调用信息的绝好方案，然而栈也有一些缺点：

​		栈维护了每个函数的调用信息直到函数返回后才释放，这需要占用相当大的空间，尤其是在程序中使用了许多递归调用的情况下。除此之外，因为有大量的信息需要保持和回复，因此生成和销毁活跃记录需要消耗一定的时间。我们需要考虑采用迭代的方案。

​		简而言之，递归过程的压栈和出栈，时间和空间都有很大的消耗。



## 2、尾递归

​		幸好可以采用一种称为**尾递归的特殊递归方式**来避免前面提到的这些缺点。

尾递归的名词解释：

- 如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。
- 当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。
- 尾递归函数的特点是在回归过程中不用做任何操作，这个特点很重要，因为大多数现代编译器会利用这种特点自动生成优化的代码。



尾递归的原理：

- 当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。
- 编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。
- 通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。



**以尾递归方式实现阶乘函数：**

```js
function facttail(n, res) {
  if(n < 0) return 0;
  if(n === 0) return 0;
  if(n === 1) return res;
  return facttail(n - 1, n * res);
}
```

那么尾递归是如何工作的，我们先用递归来计算阶乘，通过对比，看看前面所定义的递归为何不是尾递归。

- 代码1：在每次函数调用 `计算 n 倍的 (n - 1)!  的值`，让 `n = n - 1` 并持续这个过程直到 `n = 1` 为止。这种定义不是**尾递归**的，因为**每次函数调用的返回值都依赖于用 n 乘以下一次函数调用的返回值**，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。
- 代码2：函数比代码1多了个参数 `res`，除此之外没有太大区别。res（初始值为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以 n。在每次递归调用中，令 `res = n * res 并且 n = n-1`，持续调用递归，直到 n = 1 

​		代码2中的函数是尾递归的，因为对 `facttail` 的单词递归调用是函数返回前**最后执行的一条语句**。换句话说，在递归调用之后还可以有其他的语句执行，只是它们只能在递归调用没有执行时才可以执行。

​		尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如 `sum(n) = f(n) = f(n-1) + value(n)` ，会保存 n 个函数调用堆栈；而使用尾递归 `f(n, sum) = f(n-1, sum + value(n))`，这样则只保留后一个函数堆栈即可，之前的可优化删去。



> 尾递归精髓：通过参数传递结果，达到不压栈的目的。











