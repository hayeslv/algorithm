# 链表

1. 链表中的每个节点至少包含两个部分：数据域、指针域
2. 链表中的每个节点，通过指针域的值，形成一个线性结构
3. 查找节点 O(n)，插入节点 O(1)，删除节点 O(1)
4. 不适合快速的定位数据，适合动态的插入和删除数据的应用场景



## 几种链表经典的实现方式

### 方式1

- 链表节点函数

```js
function Node(data = -1, next = null) {
  this.data = data;
  this.next = next;
}
```

- 设置链表节点

```js
// 头节点
let head = null;
head = new Node(1);

// 头节点的下一个节点
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
```

现在就构造出了一条包含4个节点的链表

`1 => 2 => 3 => 4 => null`



- 遍历链表

一般情况下是从头部开始

```js
let p = head;
while(p !== null) {
  console.log(p.data);
  p = p.next;
}
```

输出：1 2 3 4 



### 方式2

- 使用两个数组分别代表**数据域**和**指针域**

```js
let data = []; // 数据域
let next = []; // 指针域
```

- 设计一个**添加节点**的函数（在`ind`这个节点后面添加节点 `p`，节点 `p` 中存储的值是 `val`）

```js
function add(ind, p, val) {
  next[ind] = p; // 让 ind 指向 p：这样就在 ind 后面添加节点 p了
  data[p] = val; // p 节点中存储的值是 val
  return;
}
```

- 设置链表节点

```js
let head = 3; // 假设头节点的下标是3
data[3] = 0; // 3节点中存储的值是 0
add(3, 5, 1); // 在 3 节点后面添加 5 节点，存储的值是 1
add(5, 2, 2); // 在 5 节点后面添加 2 节点，存储的值是 2
add(2, 7, 3);
add(7, 9, 100);
```

当前构造出的链表：`0 => 1 => 2 => 3 => 100`

- 遍历链表


```js
let p = head;
let str = ''
while(p) {
  str += data[p] + ', '
  p = next[p];
}
console.log(str);
```

输出：`0, 1, 2, 3, 100,`



## 链表的经典应用场景

### 场景1：操作系统内的动态内存分配

假设操作系统内部现在有一片 `4GB` 的内存

<img src="..\assets\链表1.png" alt="链表1" style="zoom:50%;" />

然后我们申请了 `1GB` 的内存

<img src="..\assets\链表2.png" alt="链表2" style="zoom:50%;" />

当我们申请了 `1GB` 的内存以后，我们原有的内存就变成了**两个内存碎片**

那么操作系统内部是如何维护这两个内存碎片的呢

其实操作系统维护内存碎片的一种方式，就是**把不同的内存碎片串成一个链表**

整体结构大致如下：

<img src="..\assets\链表3.png" alt="链表3" style="zoom:50%;" />

> 当我们申请完一个内存之后，剩余的内存碎片会形成一个链表结构，第一片标记的是 `2GB` 的内存，第二片标记的是 `1GB` 的内存。
>
> 这样的话，我们就不会丢掉任何的一片内存区域



### 场景2：LRU缓存淘汰算法

<img src="..\assets\链表4.png" alt="链表4" style="zoom:50%;" />

我们取数据的时候有两种方式：从硬盘中取数据（对于CPU而言速度慢）、从内存中取数据（对于CPU而言速度快）

那么我们可以将**经常用到的数据**存储到**内存**中。这个 `1GB` 的内存对于 `512GB` 的硬盘而言，就叫**缓存空间**

结果：CUP先去缓存中查找数据，如果有的话就直接使用数据，如果没有的话再去硬盘中查找数据。

> 缓存：缓存是高速设备之于低速设备的一种称呼。



我们通过链表（实际上是`hash链表`）的方式来**维护缓存**数据

- 新增数据：从链表尾部添加
- 删除数据：将链表头部的数据删除



**取数据**：

- 在缓存数据中查找
  - 如果找到了，这个就叫做**缓存命中**
  - 如果没有找到，会将新数据插入到链表最后一位，然后会把整个缓存链中最早放入的数据（链表头节点）给淘汰掉































